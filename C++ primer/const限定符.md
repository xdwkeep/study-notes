# const限定符

## 引用与常量

1. 对常量的const引用：在引用一个常量时，该引用也需要带上const，否则就会报错。对常量的引用，注意主体是一个常量。

   ```c++
   const int ci = 1024;
   const int &r1 = ci; //正确
   int &r2 = ci; //错误：试图让一个非常量去引用一个常量。
   ```

2. 对非常量的const引用。常量引用仅对引用可参与的操作做了限定，也就是说，不能通过这个引用去改变其引用对象。这也说明了const引用是可以引用非常量对象的。

   ```c++
   int ia = 1024;
   const int &r1 = ia;
   r1 = 32; //错误，这是常量引用，不能通过引用去改变引用对象的值。
   ```

3. 总结

   ```c++
   //引用对象是常量，（对常量的const引用）
   const int ci = 1024;
   const int &r1 = ci;
   
   //引用对象是非常量，（对非常量的const引用）
   int ia = 1024;
   const int &r2 = ia;
   ```

   

## 指针与常量

1. 指向常量的指针。这与对常量的引用一样。指针指向的对象是常量，那么这个指针也得带上const才行。否则报错，一个普通指针是配不上常量的。

   ```c++
   const int ia = 3;
   const int *p1 = &ia; //正确。
   int *p2 = &ia; //报错，p1只是一个普通指针而已。
   ```

2. 指向常量的指针。指向对象可以是非常量。这时代表的是，不能通过这个指针去改变指向对象的值了。这里的名字“指向常量的指针”代表的仅仅是不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变（那个对象能是非常量）

   ```c++
   int ia = 3;
   const int *p1 = &ia;
   *p1 = 4; //错误，常量指针无法通过这个指针来改变所指向对象的值了。
   ```

3. tips：所谓的指向常量的指针或引用。那只不过是指针和引用单方面”自以为是“罢了，它们觉得自己指向了常量，所以它们就自觉地不去改变所指对象的值了。

4. 常量指针。指针是对象，所以一个常量指针必须初始化，初始化完成后它的值（指针中存放的地址）就不能再改变了。

   声明的读取方式一般都是从右向左，以下代码的意思就是p1是个const对象（不能改变了），然后读*，说明这个p1是个指针（不能改变的指针），然后读int，说明这个指针的对象是int。

   ```c++
   int ia = 1024;
   int *const p1 = &ia; //p1存放的永远是ia的地址，不能再改变这个地址了。
   ```

   与`const int *p1 = &ia;`相比，p1是个指针，并且指向类型为int，然后读const，说明无法操作(int *p1)这个指针对象。

   注意，指针本身是对象并不意味着不能通过指针去修改所值对象的值。因为它不能修改的仅仅是绑定的地址值。

   ```c++
   int ia = 1024;
   int *const p1 = &ia;
   *p1 = 4; //正确
   cout << *p1 << endl; //输出为4
   ```

5. 总结。指向常量的指针，其指向对象既可以是常量又可以是非常量，这时，就不能通过这个指针来操作改变指针所指向对象的值了。常量指针，就是把地址与一个对象绑定，然后再也不能分开了，依旧可以通过指针来改变

   ```c++
   //指向常量的指针
   int ia = 1024;
   int ib = 1025;
   const int *p = &ia;
   *p = 1025; //错误，指向常量的指针不能通过指针来改变对象的值了。
   p = &ib; //正确，可以换个绑定。这时*p是1025
   
   //常量指针
   int ia = 1024;
   int ib = 1025;
   int *const p = &ia;
   *p = 1025; //正确，可以通过指针操作改变对象的值。
   p = &ib; //错误，常量指针的地址不能在改变了，绑定了ia就是永远绑定了ia。
   ```

   

