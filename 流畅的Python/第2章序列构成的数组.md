# 序列构成的数组

## 列表推导式和生成表达式

列表推导的使用方式

```python
[i for i in range(5)]
# 输出[0, 1, 2, 3, 4]
```

列表推导中，是有局部作用域的。如`x='ABC'` `[ord(x) x in x]`其中第一二个x就是局部变量，生成完后，其x认为ABC。

通常的原则是用列表推导来创建新的列表。

而生成表达式，是一个一个生成的，不会一下只产出所有，类似于range(5)一样。

## 元组

元组可以用来拆包，比如不用中间变量交换两个变量值就是其一种方式。

’_‘可以来接受不要的东西。

*是接受多余的，以列表的形式接收。

有一种叫具名元组的东西，能够快速创建一个类。使用方法如下：

```python
from collections import namedtuple
City = namedtuple('City', 'name country')
tokyo = City('Tokyo', 'JP')
```

## 切片

众所周知，形如[a:b:c]的形式，表示了从a到b（左闭右开）以c为间隔取数。其中，若c为-1，表示逆序取。

因为赋值的对象是切片，那么右侧得是一个可迭代对象才行。

注意对以下的理解

```python
li = list(range(10))
li[2:5] = [30, 40]
# li变为[0, 1, 30, 40, 5, 6, 7, 8, 9]
```

## 对序列使用+和*

首先需要注意两种方式都不会改变原有对象，而产生一个新的序列。

对于嵌套的列表，如果想要生成，那么最好使用列表生成。因为若是用*，那么会是同一个序列重复引用。具体情形如下：

```python
# 列表生成的方式
board = [['_'] * 3 for i in range(3)]
# 此时board = [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
board[1][2] = 'X'
# 此时board = [['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]

# 3个指向同一对象的引用的列表
board = [['_'] * 3] * 3
# 此时board = [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
board[1][2] = 'X'
# 此时board = [['_', '_', 'X'], ['_', '_', 'X'], ['_', '_', 'X']]
```

## 序列的增量赋值

+=和*=，都是就地施法。即调用的是左侧对象的__iadd__特殊方法。

关于对元组这种不可变序列上的使用，那么还是会改变地址的，新的元组会被创建。

## list.sort和sorted

list.sort是就地排序的，返回None，表示就地排序。sorted返回一个列表（无论如何都是返回一个列表）。

这两个函数都有两个可选参数。reverse默认为False，表示升序。key是一个只有一个参数的函数，可排序时作用于每个元素。

